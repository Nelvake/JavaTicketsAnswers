Билет № 3.

1. Interface и Abstract Class. Краткое сравнение.
2. Atomic классы, в чем преимущество, где используются.
3. Spring – назовите 3 возможных способа конфигурации.

1. Интерфейс — это ссылочный тип в Java. Он схож с классом. Это совокупность абстрактных методов. 
Класс реализует интерфейс, таким образом наследуя абстрактные методы интерфейса.
Вместе с абстрактными методами интерфейс в Java может содержать константы, обычные методы, статические методы и вложенные типы. 
Тела методов существуют только для обычных методов и статических методов.

Абстрактный класс похож на обычный класс. В абстрактном классе также можно определить поля и методы, 
но в то же время нельзя создать объект или экземпляр абстрактного класса. 
Абстрактные классы призваны предоставлять базовый функционал для классов-наследников. 
А производные классы уже реализуют этот функционал.

Абстрактный класс позволяет вам создавать функциональные возможности, которые подклассы могут реализовать или переопределить, 
тогда как интерфейс позволяет вам только указывать функциональность, но не реализовывать ее. 
Класс может расширять только один абстрактный класс, в то время как класс может реализовывать несколько интерфейсов.

2.
• AtomicBoolean
• AtomicInteger
• AtomicLong
• AtomicReference	

Atomic-классы для boolean, integer, long и ссылок на объекты.
Классы этой группы содержат метод compareAndSet, принимающий 2 аргумента : предполагаемое текущее и новое значения. Метод устанавливает объекту новое значение, если текущее равно предполагаемому, и возвращает true. Если текущее значение изменилось, то метод вернет false и новое значение не будет установлено.
Кроме этого, классы имеют метод getAndSet, который безусловно устанавливает новое значение и возвращает старое.
Классы AtomicInteger и AtomicLong имеют также методы инкремента/декремента/добавления нового значения.

• AtomicIntegerArray
• AtomicLongArray
• AtomicReferenceArray	

Atomic-классы для массивов integer, long и ссылок на объекты.Элементы массивов могут быть изменены атомарно.

• AtomicIntegerFieldUpdater
• AtomicLongFieldUpdater
• AtomicReferenceFieldUpdater

Atomic-классы для обновления полей по их именам с использованием reflection.
Смещения полей для CAS операций определяется в конструкторе и кэшируются. 
Сильного падения производительности из-за reflection не наблюдается.

• AtomicStampedReference
• AtomicMarkableReference
	
Atomic-классы для реализации некоторых алгоритмов, (точнее сказать, уход от проблем при реализации алгоритмов).
Класс AtomicStampedReference получает в качестве параметров ссылку на объект и int значение.
Класс AtomicMarkableReference получает в качестве параметров ссылку на объект и битовый флаг (true/false).

Преимущество классов Atomic* заключается в том, что они предоставляют атомарный метод compare-and-swap, 
который может быть очень полезен для реализации алгоритмов без блокировки.

3. Возможные конфигурации:
• На основе xml, когда  конфигурация описывается в xml-файле.
• На основе Java, когда конфигурация - это Java класс, помеченный определенными аннотациями.
• На основе groovy, когда конфигурация представляет собой файл с кодом Groovy.